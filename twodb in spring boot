application properties 

spring.application.name=twodb
server.port=8181

datasource.primary.jdbc-url=jdbc:h2:mem:dbone
datasource.primary.username=one
datasource.primary.password=one
datasource.primary.driverClassName=org.h2.Driver

datasource.secondary.jdbc-url=jdbc:h2:mem:dbtwo
datasource.secondary.username=two
datasource.secondary.password=two
datasource.secondary.driverClassName=org.h2.Driver


spring.h2.console.path=/h2-console
spring.h2.console.enabled=true
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true


one DB config

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.boot.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import jakarta.persistence.EntityManagerFactory;

@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
        basePackages = "com.example.twodb.primary.repo",
        entityManagerFactoryRef = "primaryEntityManagerFactory",
        transactionManagerRef = "primaryTransactionManager"
)
public class UserDbConfig {

    @Primary
    @Bean
    @ConfigurationProperties(prefix = "datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Primary
    @Bean
    public LocalContainerEntityManagerFactoryBean primaryEntityManagerFactory(
            EntityManagerFactoryBuilder builder) {

        return builder
                .dataSource(primaryDataSource())
                .packages("com.example.twodb.primary.entity")
                .persistenceUnit("primaryPU")
                .build();
    }

    @Primary
    @Bean
    public PlatformTransactionManager primaryTransactionManager(
            @Qualifier("primaryEntityManagerFactory") EntityManagerFactory emf) {

        return new JpaTransactionManager(emf);
    }
}


second db config

@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
        basePackages = "com.example.twodb.secondary.repo",
        entityManagerFactoryRef = "secondaryEntityManagerFactory",
        transactionManagerRef = "secondaryTrasactionManager"
        )

public class AddressDbConfig {

    
    @Bean
    @ConfigurationProperties(prefix = "datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public LocalContainerEntityManagerFactoryBean secondaryEntityManagerFactory(EntityManagerFactoryBuilder builder) {
        return builder
                .dataSource(secondaryDataSource())
                .packages("com.example.twodb.secondary.entity")
                .persistenceUnit("secondarydb")
                .build();
        
    }
    
    @Bean
    public PlatformTransactionManager secondaryTrasactionManager(
            @Qualifier("secondaryEntityManagerFactory") EntityManagerFactory fac) {
        return new JpaTransactionManager(fac);
        
    }
}


---------------------------------------------------------------------------------
@configuration - mark class as source of beans
@enabletransactionmanagement : enables annotation driven transaction mangement which allow us to use transactional annotation
@enableJparepository : bind repo to specific database  
basepackage : where repo are located
entitymanagerFactory = which entity to use
trasctionmanagerRef = which trasaction manager to use
(this will tell that repo in this package use this database config)


4. datasource bean
create db connection use primary to use by default
@configurationproperites used to bind properties with prefix in application properties file


5. entitymanagerfactory 
creates entitymanager manages persistence context
datasource which db to use
packages where the entities are
persistanceUnit logiacal db identifier

6. TransactionManager bean
it ensures trasactions are applied only to the primary database

Below are clean, interview-ready notes for Two (Multiple) Database Configuration in Spring Boot, written in a step-by-step teaching style, with why, what, and how clearly explained.
These notes are suitable for experienced Java / Spring Boot interviews.
Two Database Configuration in Spring Boot ‚Äì Notes
1. Why Multiple Databases in Spring Boot?
In real-world applications (banking, audit, reporting):
One database for core business data
Another database for audit / logs / reports
Sometimes read & write databases are separated
Spring Boot supports multiple DataSources, but we must configure them manually.
2. Application Properties Configuration
Purpose
Define connection details for each database
Each database is identified using a custom prefix
Key Point (Interview)
üëâ When using multiple databases, do NOT use spring.datasource
üëâ Use custom prefixes like datasource.primary, datasource.secondary
Example (application.properties)
Copy code
Properties
spring.application.name=twodb
server.port=8181

datasource.primary.jdbc-url=jdbc:h2:mem:dbone
datasource.primary.username=one
datasource.primary.password=one
datasource.primary.driverClassName=org.h2.Driver

datasource.secondary.jdbc-url=jdbc:h2:mem:dbtwo
datasource.secondary.username=two
datasource.secondary.password=two
datasource.secondary.driverClassName=org.h2.Driver

spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
Interview Tip
jdbc-url is mandatory when DataSourceBuilder is used
@ConfigurationProperties binds these values automatically
3. DataSource Configuration
What is DataSource?
Represents database connection pool
Holds URL, username, password, driver
Why @ConfigurationProperties?
Automatically maps properties using prefix
Avoids hardcoding credentials
Primary DataSource
Copy code
Java
@Primary
@Bean
@ConfigurationProperties(prefix = "datasource.primary")
public DataSource primaryDataSource() {
    return DataSourceBuilder.create().build();
}
Important Annotations
Annotation
Purpose
@Bean
Creates Spring-managed bean
@ConfigurationProperties
Loads DB properties
@Primary
Default DataSource if no qualifier is used
4. EntityManagerFactory Configuration
What is EntityManagerFactory?
Responsible for:
Managing entities
Creating EntityManager
Handling persistence context
Why Separate EntityManagerFactory?
Each database:
Has different entities
Has different persistence unit
Configuration
Copy code
Java
@Primary
@Bean
public LocalContainerEntityManagerFactoryBean primaryEntityManagerFactory(
        EntityManagerFactoryBuilder builder) {

    return builder
            .dataSource(primaryDataSource())
            .packages("com.example.twodb.primary.entity")
            .persistenceUnit("primaryPU")
            .build();
}
Interview Key Points
packages() ‚Üí tells where entity classes are
persistenceUnit() ‚Üí logical name for DB
One DB = One EntityManagerFactory
5. TransactionManager Configuration
Why TransactionManager?
Handles:
Commit
Rollback
Transaction boundaries
Each database must have: üëâ Its own TransactionManager
Configuration
Copy code
Java
@Primary
@Bean
public PlatformTransactionManager primaryTransactionManager(
        @Qualifier("primaryEntityManagerFactory") EntityManagerFactory emf) {

    return new JpaTransactionManager(emf);
}
Why @Qualifier?
Multiple EntityManagerFactory beans exist
Spring needs to know which one to inject
6. @EnableJpaRepositories Configuration
Why Required?
When multiple databases exist:
Spring cannot auto-detect repositories
We must explicitly define:
Repository package
EntityManagerFactory
TransactionManager
Configuration
Copy code
Java
@EnableJpaRepositories(
    basePackages = "com.example.twodb.primary.repo",
    entityManagerFactoryRef = "primaryEntityManagerFactory",
    transactionManagerRef = "primaryTransactionManager"
)
Interview Question
What happens if this is not configured? üëâ Spring throws No qualifying bean or wrong DB mapping errors
7. Complete Primary DB Configuration Class
Copy code
Java
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
    basePackages = "com.example.twodb.primary.repo",
    entityManagerFactoryRef = "primaryEntityManagerFactory",
    transactionManagerRef = "primaryTransactionManager"
)
public class UserDbConfig {

    @Primary
    @Bean
    @ConfigurationProperties(prefix = "datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Primary
    @Bean
    public LocalContainerEntityManagerFactoryBean primaryEntityManagerFactory(
            EntityManagerFactoryBuilder builder) {

        return builder
                .dataSource(primaryDataSource())
                .packages("com.example.twodb.primary.entity")
                .persistenceUnit("primaryPU")
                .build();
    }

    @Primary
    @Bean
    public PlatformTransactionManager primaryTransactionManager(
            @Qualifier("primaryEntityManagerFactory") EntityManagerFactory emf) {

        return new JpaTransactionManager(emf);
    }
}
8. Secondary Database Configuration
Key Differences
No @Primary
Different:
Property prefix
Entity package
Repository package
Persistence unit
Copy code
Java
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
    basePackages = "com.example.twodb.secondary.repo",
    entityManagerFactoryRef = "secondaryEntityManagerFactory",
    transactionManagerRef = "secondaryTransactionManager"
)
public class AddressDbConfig {

    @Bean
    @ConfigurationProperties(prefix = "datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean secondaryEntityManagerFactory(
            EntityManagerFactoryBuilder builder) {

        return builder
                .dataSource(secondaryDataSource())
                .packages("com.example.twodb.secondary.entity")
                .persistenceUnit("secondaryPU")
                .build();
    }

    @Bean
    public PlatformTransactionManager secondaryTransactionManager(
            @Qualifier("secondaryEntityManagerFactory") EntityManagerFactory emf) {

        return new JpaTransactionManager(emf);
    }
}
9. Package Structure (Best Practice)
Copy code

com.example.twodb
 ‚îú‚îÄ‚îÄ primary
 ‚îÇ   ‚îú‚îÄ‚îÄ entity
 ‚îÇ   ‚îú‚îÄ‚îÄ repo
 ‚îÇ   ‚îî‚îÄ‚îÄ config
 ‚îú‚îÄ‚îÄ secondary
 ‚îÇ   ‚îú‚îÄ‚îÄ entity
 ‚îÇ   ‚îú‚îÄ‚îÄ repo
 ‚îÇ   ‚îî‚îÄ‚îÄ config
10. Common Interview Questions & Answers
Q1. Why @Primary is required?
Answer:
When multiple beans of same type exist, @Primary tells Spring which one to use by default.
Q2. Can we use one TransactionManager for two databases?
Answer:
‚ùå No.
Each database requires its own TransactionManager.
Q3. What happens if repositories are mixed?
Answer:
Entities may be saved in the wrong database, or application may fail at startup.
Q4. Can we add a third database?
Answer:
‚úÖ Yes.
Just repeat the same steps:
Properties
DataSource
EntityManagerFactory
TransactionManager
Repository configuration
11. Summary (One-Line Revision)
Each database needs its own DataSource, EntityManagerFactory, TransactionManager, and repository configuration.
If you want, next I can:
Add service-layer usage example
Explain @Transactional with multiple DBs
Convert this into interview Q&A format
Create a diagram explanation for better memory
Just tell me üëç


